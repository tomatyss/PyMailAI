# PyMailAI

PyMailAI is a Python package that enables AI agents to use email as an interface for communication. It provides simple wrappers and implementations to process emails as input and generate responses as output.

## Features

- Email client interface (IMAP/SMTP)
- Message processing utilities
- AI agent integration interfaces
- Configurable email settings
- Async support for better performance
- Easy integration with LLM platforms

## Installation

```bash
pip install pymailai
```

## Quick Start

### Basic Usage

```python
from pymailai import EmailAgent, EmailConfig

# Configure email settings
config = EmailConfig(
    imap_server="imap.gmail.com",
    smtp_server="smtp.gmail.com",
    email="your-email@gmail.com",
    password="your-app-password"
)

# Create an email agent
agent = EmailAgent(config)

# Start processing emails
await agent.start()
```

### Integration with OpenAI

```python
import os
import openai
from typing import Optional
from pydantic import BaseModel, Field
from pymailai import EmailAgent, EmailConfig
from pymailai.message import EmailData

# Configure OpenAI
openai.api_key = "your-openai-api-key"

class EmailResponse(BaseModel):
    """Structure for AI-generated email responses."""
    subject: str = Field(description="Email subject line")
    body: str = Field(description="Main email content")
    tone: str = Field(description="Tone of the response (professional/friendly/etc)")

async def ai_email_handler(message: EmailData) -> Optional[EmailData]:
    """Process emails using OpenAI."""
    
    # Create prompt for the AI
    prompt = f"""
    Process this email and generate a response:
    
    Subject: {message.subject}
    From: {message.from_address}
    Content: {message.body_text}
    
    Generate a professional and helpful response.
    """
    
    # Get AI response
    response = await openai.ChatCompletion.acreate(
        model="gpt-4",
        messages=[
            {"role": "system", "content": "You are a helpful email assistant."},
            {"role": "user", "content": prompt}
        ],
        functions=[{
            "name": "generate_email_response",
            "description": "Generate a structured email response",
            "parameters": EmailResponse.schema()
        }],
        function_call={"name": "generate_email_response"}
    )
    
    # Parse the structured response
    response_data = EmailResponse.parse_raw(
        response.choices[0].message.function_call.arguments
    )
    
    # Create email response
    return EmailData(
        message_id="",  # Will be generated by email server
        subject=f"Re: {response_data.subject}",
        from_address=message.to_addresses[0],
        to_addresses=[message.from_address],
        cc_addresses=[],
        body_text=response_data.body,
        body_html=None,
        timestamp=message.timestamp,
        in_reply_to=message.message_id,
        references=[message.message_id] if message.references is None 
                  else message.references + [message.message_id]
    )

# Example usage
async def main():
    config = EmailConfig(
        imap_server=os.getenv("EMAIL_IMAP_SERVER", "imap.gmail.com"),
        smtp_server=os.getenv("EMAIL_SMTP_SERVER", "smtp.gmail.com"),
        email=os.getenv("EMAIL_ADDRESS"),
        password=os.getenv("EMAIL_PASSWORD")
    )
    
    async with EmailAgent(config, message_handler=ai_email_handler) as agent:
        print(f"AI Email Agent started. Monitoring {config.email}")
        try:
            while True:
                await asyncio.sleep(1)
        except KeyboardInterrupt:
            print("\nStopping email agent...")

if __name__ == "__main__":
    asyncio.run(main())
```

### Integration with Anthropic Claude

```python
import anthropic
from pymailai import EmailAgent, EmailConfig
from pymailai.message import EmailData

class ClaudeEmailAgent(EmailAgent):
    """Email agent powered by Anthropic's Claude."""
    
    def __init__(self, config: EmailConfig, claude_api_key: str):
        super().__init__(config)
        self.claude = anthropic.Client(api_key=claude_api_key)
    
    async def process_message(self, message: EmailData) -> Optional[EmailData]:
        # Create prompt for Claude
        prompt = f"""
        Process this email and generate a response:
        
        Subject: {message.subject}
        From: {message.from_address}
        Content: {message.body_text}
        
        Generate a professional and helpful response.
        """
        
        # Get Claude's response
        response = self.claude.messages.create(
            model="claude-2",
            messages=[{
                "role": "user",
                "content": prompt
            }]
        )
        
        # Create email response
        return EmailData(
            message_id="",
            subject=f"Re: {message.subject}",
            from_address=message.to_addresses[0],
            to_addresses=[message.from_address],
            cc_addresses=[],
            body_text=response.content,
            body_html=None,
            timestamp=message.timestamp,
            in_reply_to=message.message_id,
            references=[message.message_id] if message.references is None 
                      else message.references + [message.message_id]
        )

# Example usage
async def main():
    config = EmailConfig(
        imap_server="imap.gmail.com",
        smtp_server="smtp.gmail.com",
        email="your-email@gmail.com",
        password="your-app-password"
    )
    
    agent = ClaudeEmailAgent(config, claude_api_key="your-claude-api-key")
    async with agent:
        print(f"Claude Email Agent started. Monitoring {config.email}")
        try:
            while True:
                await asyncio.sleep(1)
        except KeyboardInterrupt:
            print("\nStopping email agent...")

if __name__ == "__main__":
    asyncio.run(main())
```

## License

MIT License
